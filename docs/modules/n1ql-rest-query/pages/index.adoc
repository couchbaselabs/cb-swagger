= Query Service REST API
:keywords: OpenAPI, REST
:specDir: partial$
:snippetDir: partial$paths/
:page-topic-type: reference
:page-toclevels: 2
include::partial$header-attributes.adoc[opts=optional]

[comment]
This file is created automatically by OpenAPI Generator.
DO NOT EDIT! See https://github.com/couchbase/cb-swagger

:leveloffset: 1

include::{specDir}overview/document-before.adoc[opts=optional]


[[overview]]
= Overview

:leveloffset: +1

// markup not found, no include::{specDir}overview/document-begin.adoc[opts=optional]


[markdown]
--
The Query Service REST API is provided by the Query service.
This API enables you to run SQL++ queries and set request-level parameters.

--

[discrete#version]
= Version information
[%hardbreaks]
__Version__ : 7.6

[discrete#host]
= Host information

....
http://localhost:8093
....




// markup not found, no include::{specDir}overview/document-end.adoc[opts=optional]

:leveloffset: -1


include::{specDir}overview/document-after.adoc[opts=optional]



// markup not found, no include::{specDir}paths/document-before.adoc[opts=optional]


[[resources]]
= Resources

:count-apis: 1

:leveloffset: +1

// markup not found, no include::{specDir}paths/document-begin.adoc[opts=optional]


This section describes the operations available with this REST API.
ifeval::[{count-apis} > 1]
The operations are grouped in the following categories.

[%hardbreaks]
<<tag-Default>>
endif::[]


ifeval::[{count-apis} > 1]
[#tag-Default]
= Default
:leveloffset: +1

ifeval::["" != ""]

endif::[]
ifeval::["" == ""]
**{toc-title}**
endif::[]
endif::[]

[%hardbreaks]
<<get_service>>
<<post_service>>



// markup not found, no include::{specDir}paths/get_service/operation-before.adoc[opts=optional]


[#get_service]
= Read-Only Query Service

:leveloffset: +1

// markup not found, no include::{specDir}paths/get_service/operation-begin.adoc[opts=optional]


....
GET /query/service
....



// markup not found, no include::{specDir}paths/get_service/operation-description-before.adoc[opts=optional]


[#get_service-description]
= Description

:leveloffset: +1

// markup not found, no include::{specDir}paths/get_service/operation-description-begin.adoc[opts=optional]


[markdown]
--
Enables you to execute a SQL++ statement. This method allows you to run queries and modifying statements, and specify query parameters. It does not allow you to run modifying statements.

This endpoint is intended for situations where use of the `POST` method is restricted.

--


// markup not found, no include::{specDir}paths/get_service/operation-description-end.adoc[opts=optional]

:leveloffset: -1


include::{specDir}paths/get_service/operation-description-after.adoc[opts=optional]



// markup not found, no include::{specDir}paths/get_service/operation-parameters-before.adoc[opts=optional]






// markup not found, no include::{specDir}paths/get_service/operation-parameters-after.adoc[opts=optional]


[#get_service-produces]
= Produces

* application/json



// markup not found, no include::{specDir}paths/get_service/operation-responses-before.adoc[opts=optional]


[#get_service-responses]
= Responses

:leveloffset: +1

include::{specDir}paths/get_service/operation-responses-begin.adoc[opts=optional]


[cols="20,60,20"]
|===
| HTTP Code | Description | Schema

| 200
a| [markdown]
--
The operation was successful.
--
| <<Response>>

| 400
a| [markdown]
--
Bad Request. The request cannot be processed for one of the following reasons:  the statement contains a SQL++ syntax error;  the request has a missing or unrecognized HTTP parameter;  the request is badly formatted &mdash; for example, the request body contains a JSON syntax error.
--
| 

| 401
a| [markdown]
--
Unauthorized. The credentials provided with the request are missing or invalid. 
--
| 

| 403
a| [markdown]
--
Forbidden. There is a read-only violation. Either there was an attempt to create or update in a GET request or a POST request where `readonly` is set, or the client does not have the authorization to modify an object (index, keyspace or namespace) in the statement. 
--
| 

| 404
a| [markdown]
--
Not found. The statement in the request references an invalid namespace or keyspace. 
--
| 

| 405
a| [markdown]
--
Method not allowed. The statement in the request references an invalid namespace or keyspace. 
--
| 

| 409
a| [markdown]
--
Conflict. There is an attempt to create an object (keyspace or index) that already exists. 
--
| 

| 410
a| [markdown]
--
Gone. The server is shutting down gracefully. Previously made requests are being completed, but no new requests are being accepted. 
--
| 

| 413
a| [markdown]
--
Payload too large. The query is too large for the Query Service to process. 
--
| 

| 500
a| [markdown]
--
Internal server error. There was an unforeseen problem processing the request. 
--
| 

| 503
a| [markdown]
--
Service unavailable. There is an issue (that is possibly temporary) preventing the request being processed; the request queue is full or the data store is not accessible. 
--
| 


|===


// markup not found, no include::{specDir}paths/get_service/operation-responses-end.adoc[opts=optional]

:leveloffset: -1



// markup not found, no include::{specDir}paths/get_service/operation-responses-after.adoc[opts=optional]



// markup not found, no include::{specDir}paths/get_service/operation-security-before.adoc[opts=optional]


[#get_service-security]
= Security

:leveloffset: +1

// markup not found, no include::{specDir}paths/get_service/operation-security-begin.adoc[opts=optional]


[cols="20,80"]
|===
| Type | Name

| http (basic)
| <<security-header>>
| apiKey
| <<security-parameter>>

|===


// markup not found, no include::{specDir}paths/get_service/operation-security-end.adoc[opts=optional]

:leveloffset: -1


// markup not found, no include::{specDir}paths/get_service/operation-security-after.adoc[opts=optional]



include::{snippetDir}get_service/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}get_service/http-response.adoc[opts=optional]



// markup not found, no include::{specDir}paths/get_service/operation-end.adoc[opts=optional]

:leveloffset: -1


// markup not found, no include::{specDir}paths/get_service/operation-after.adoc[opts=optional]




// markup not found, no include::{specDir}paths/post_service/operation-before.adoc[opts=optional]


[#post_service]
= Query Service

:leveloffset: +1

// markup not found, no include::{specDir}paths/post_service/operation-begin.adoc[opts=optional]


....
POST /query/service
....



// markup not found, no include::{specDir}paths/post_service/operation-description-before.adoc[opts=optional]


[#post_service-description]
= Description

:leveloffset: +1

// markup not found, no include::{specDir}paths/post_service/operation-description-begin.adoc[opts=optional]


[markdown]
--
Enables you to execute a SQL++ statement. This method allows you to run queries and modifying statements, and specify query parameters.

--


// markup not found, no include::{specDir}paths/post_service/operation-description-end.adoc[opts=optional]

:leveloffset: -1


// markup not found, no include::{specDir}paths/post_service/operation-description-after.adoc[opts=optional]



// markup not found, no include::{specDir}paths/post_service/operation-parameters-before.adoc[opts=optional]


[#post_service-parameters]
= Parameters

:leveloffset: +1

include::{specDir}paths/post_service/operation-parameters-begin.adoc[opts=optional]






[#post_service-body]
.Body Parameter
{blank}

[cols="20,60,20"]
|===
|Name| Description| Schema

a| *Body* +
_required_
a| 


[markdown]
--

An object specifying one or more query parameters.
--

[%hardbreaks]
{blank}

| <<Request>>


|===


// markup not found, no include::{specDir}paths/post_service/operation-parameters-end.adoc[opts=optional]

:leveloffset: -1




// markup not found, no include::{specDir}paths/post_service/operation-parameters-after.adoc[opts=optional]


[#post_service-produces]
= Produces

* application/json

[#post_service-consumes]
= Consumes

* application/json
* application/x-www-form-urlencoded


// markup not found, no include::{specDir}paths/post_service/operation-responses-before.adoc[opts=optional]


[#post_service-responses]
= Responses

:leveloffset: +1

include::{specDir}paths/post_service/operation-responses-begin.adoc[opts=optional]


[cols="20,60,20"]
|===
| HTTP Code | Description | Schema

| 200
a| [markdown]
--
The operation was successful.
--
| <<Response>>

| 400
a| [markdown]
--
Bad Request. The request cannot be processed for one of the following reasons:  the statement contains a SQL++ syntax error;  the request has a missing or unrecognized HTTP parameter;  the request is badly formatted &mdash; for example, the request body contains a JSON syntax error.
--
| 

| 401
a| [markdown]
--
Unauthorized. The credentials provided with the request are missing or invalid. 
--
| 

| 403
a| [markdown]
--
Forbidden. There is a read-only violation. Either there was an attempt to create or update in a GET request or a POST request where `readonly` is set, or the client does not have the authorization to modify an object (index, keyspace or namespace) in the statement. 
--
| 

| 404
a| [markdown]
--
Not found. The statement in the request references an invalid namespace or keyspace. 
--
| 

| 405
a| [markdown]
--
Method not allowed. The statement in the request references an invalid namespace or keyspace. 
--
| 

| 409
a| [markdown]
--
Conflict. There is an attempt to create an object (keyspace or index) that already exists. 
--
| 

| 410
a| [markdown]
--
Gone. The server is shutting down gracefully. Previously made requests are being completed, but no new requests are being accepted. 
--
| 

| 413
a| [markdown]
--
Payload too large. The query is too large for the Query Service to process. 
--
| 

| 500
a| [markdown]
--
Internal server error. There was an unforeseen problem processing the request. 
--
| 

| 503
a| [markdown]
--
Service unavailable. There is an issue (that is possibly temporary) preventing the request being processed; the request queue is full or the data store is not accessible. 
--
| 


|===


// markup not found, no include::{specDir}paths/post_service/operation-responses-end.adoc[opts=optional]

:leveloffset: -1



// markup not found, no include::{specDir}paths/post_service/operation-responses-after.adoc[opts=optional]



// markup not found, no include::{specDir}paths/post_service/operation-security-before.adoc[opts=optional]


[#post_service-security]
= Security

:leveloffset: +1

// markup not found, no include::{specDir}paths/post_service/operation-security-begin.adoc[opts=optional]


[cols="20,80"]
|===
| Type | Name

| http (basic)
| <<security-header>>
| apiKey
| <<security-parameter>>

|===


// markup not found, no include::{specDir}paths/post_service/operation-security-end.adoc[opts=optional]

:leveloffset: -1


// markup not found, no include::{specDir}paths/post_service/operation-security-after.adoc[opts=optional]



include::{snippetDir}post_service/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}post_service/http-response.adoc[opts=optional]



// markup not found, no include::{specDir}paths/post_service/operation-end.adoc[opts=optional]

:leveloffset: -1


// markup not found, no include::{specDir}paths/post_service/operation-after.adoc[opts=optional]



ifeval::[{count-apis} > 1]
:leveloffset: -1
endif::[]



// markup not found, no include::{specDir}paths/document-end.adoc[opts=optional]

:leveloffset: -1


// markup not found, no include::{specDir}paths/document-after.adoc[opts=optional]



// markup not found, no include::{specDir}definitions/document-before.adoc[opts=optional]


[#models]
= Definitions

:count-models: 9

:leveloffset: +1

// markup not found, no include::{specDir}definitions/document-begin.adoc[opts=optional]


This section describes the properties consumed and returned by this REST API.

ifeval::[{count-models} > 1]
ifdef::collapse-models[]
[.two-columns]
endif::collapse-models[]
[%hardbreaks]
<<Conditions>>
<<Controls>>
<<Credentials>>
<<Execution_Timings>>
<<Metrics>>
<<Profile>>
<<Request>>
<<Response>>
<<Statistics>>
endif::[]



// markup not found, no include::{specDir}definitions/Conditions/definition-before.adoc[opts=optional]


ifdef::collapse-models[]
[discrete]
endif::collapse-models[]
[#Conditions]
= Conditions

:leveloffset: +1

// markup not found, no include::{specDir}definitions/Conditions/definition-begin.adoc[opts=optional]


.icon:brackets-curly[fw] Object
{blank}

//tag::Conditions[]

ifdef::model-descriptions[]
//tag::desc-Conditions[]
Errors and warnings have the following format.
//end::desc-Conditions[]
endif::model-descriptions[]

[cols="25,55,20"]
|===
| Property | | Schema

a| 
*code* +
_required_
a| 

[markdown]
--
A unique number that identifies the error or warning. The code ranges are partitioned by component. The codes can also include parts that indicate severity and transience. This property is always present in every condition returned in the Query REST API or captured in a log.

--

[%hardbreaks]
{blank}
| Integer

a| 
*msg* +
_required_
a| 

[markdown]
--
A message describing the error or warning in detail. This property is always present in every condition returned in the Query REST API or captured in a log.

--

[%hardbreaks]
{blank}
| String

a| 
*name* +
_optional_
a| 

[markdown]
--
Unique name that has a 1:1 mapping to the code. Uniquely identifies the condition. This property is helpful for pattern matching and can have meaning, making it more memorable than the code. The name should be fully qualified.

--

[%hardbreaks]
*Example:* `pass:c["indexing.scan.io_failure"]`
{blank}
| String

a| 
*sev* +
_optional_
a| 

[markdown]
--
One of the following SQL++ severity levels, listed in order of severity:

 1. Severe
 2. Error
 3. Warn
 4. Info

--

[%hardbreaks]
{blank}
| Integer

a| 
*temp* +
_optional_
a| 

[markdown]
--
Indicates if the condition is transient &mdash; for example, the queue is full. If the value is `false`, it tells clients and users that a retry without modification produces the same condition.

--

[%hardbreaks]
{blank}
| Boolean

|===

//end::Conditions[]




include::{specDir}definitions/Conditions/definition-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/Conditions/definition-after.adoc[opts=optional]




// markup not found, no include::{specDir}definitions/Controls/definition-before.adoc[opts=optional]


ifdef::collapse-models[]
[discrete]
endif::collapse-models[]
[#Controls]
= Controls

:leveloffset: +1

// markup not found, no include::{specDir}definitions/Controls/definition-begin.adoc[opts=optional]


.icon:brackets-curly[fw] Object
{blank}

//tag::Controls[]

ifdef::model-descriptions[]
//tag::desc-Controls[]
An object containing runtime information provided along with the request. Present only if `controls` was set to true in the [Request Parameters](#Request).

//end::desc-Controls[]
endif::model-descriptions[]

[cols="25,55,20"]
|===
| Property | | Schema

a| 
*scan_consistency* +
_optional_
a| 

[markdown]
--
The value of the query setting Scan Consistency used for the query.
--

[%hardbreaks]
{blank}
| String

a| 
*use_cbo* +
_optional_
a| 

[markdown]
--
Whether the cost-based optimizer was enabled for the query.
--

[%hardbreaks]
{blank}
| Boolean

a| 
*memoryQuota* +
_optional_
a| 

[markdown]
--
The memory quota for the request, in MB. This property is only returned if a memory quota was set for the query.

--

[%hardbreaks]
{blank}
| Integer (unsigned)

a| 
*stmtType* +
_optional_
a| 

[markdown]
--
The type of query statement.
--

[%hardbreaks]
*Example:* `pass:c["SELECT"]`
{blank}
| String

|===

//end::Controls[]




include::{specDir}definitions/Controls/definition-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/Controls/definition-after.adoc[opts=optional]




// markup not found, no include::{specDir}definitions/Credentials/definition-before.adoc[opts=optional]


ifdef::collapse-models[]
[discrete]
endif::collapse-models[]
[#Credentials]
= Credentials

:leveloffset: +1

// markup not found, no include::{specDir}definitions/Credentials/definition-begin.adoc[opts=optional]


.icon:brackets-curly[fw] Object
{blank}

//tag::Credentials[]


[cols="25,55,20"]
|===
| Property | | Schema

a| 
*user* +
_optional_
a| 

[markdown]
--
An identity for authentication. Note that bucket names may be prefixed with `local:`, and admin names may be prefixed with `admin:`.

--

[%hardbreaks]
*Example:* `pass:c["local:bucket-name"]`
{blank}
| String

a| 
*pass* +
_optional_
a| 

[markdown]
--
A password for authentication.
--

[%hardbreaks]
*Example:* `pass:c["password"]`
{blank}
| String

|===

//end::Credentials[]




// markup not found, no include::{specDir}definitions/Credentials/definition-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/Credentials/definition-after.adoc[opts=optional]




// markup not found, no include::{specDir}definitions/Execution_Timings/definition-before.adoc[opts=optional]


ifdef::collapse-models[]
[discrete]
endif::collapse-models[]
[#Execution_Timings]
= Execution Timings

:leveloffset: +1

// markup not found, no include::{specDir}definitions/Execution_Timings/definition-begin.adoc[opts=optional]


.icon:brackets-curly[fw] Object
{blank}

//tag::Execution_Timings[]

ifdef::model-descriptions[]
//tag::desc-Execution_Timings[]
Present only if `profile` was set to `"timings"` in the [Request Parameters](#Request).

The execution details for various phases involved in the query execution, such as kernel and service execution times, number of documents processed at each query operator in each phase, and number of phase switches.

//end::desc-Execution_Timings[]
endif::model-descriptions[]

[cols="25,55,20"]
|===
| Property | | Schema

a| 
*#operator* +
_required_
a| 

[markdown]
--
Name of the operator.
--

[%hardbreaks]
*Example:* `pass:c["Fetch"]`
{blank}
| String

a| 
*#stats* +
_required_
a| 

[markdown]
--
include::index.adoc[tag=desc-Statistics, opts=optional]
--

[%hardbreaks]
{blank}
| <<Statistics>>

a| 
*~child* +
_optional_
a| 

[markdown]
--
Further nested operators, each with their own execution timings.
--

[%hardbreaks]
{blank}
| Object

|===

//end::Execution_Timings[]




// markup not found, no include::{specDir}definitions/Execution_Timings/definition-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/Execution_Timings/definition-after.adoc[opts=optional]




// markup not found, no include::{specDir}definitions/Metrics/definition-before.adoc[opts=optional]


ifdef::collapse-models[]
[discrete]
endif::collapse-models[]
[#Metrics]
= Metrics

:leveloffset: +1

// markup not found, no include::{specDir}definitions/Metrics/definition-begin.adoc[opts=optional]


.icon:brackets-curly[fw] Object
{blank}

//tag::Metrics[]

ifdef::model-descriptions[]
//tag::desc-Metrics[]
An object containing metrics about the request.
//end::desc-Metrics[]
endif::model-descriptions[]

[cols="25,55,20"]
|===
| Property | | Schema

a| 
*elapsedTime* +
_required_
a| 

[markdown]
--
The total time taken for the request, that is the time from when the request was received until the results were returned.
--

[%hardbreaks]
{blank}
| String

a| 
*executionTime* +
_required_
a| 

[markdown]
--
The time taken for the execution of the request, that is the time from when query execution started until the results were returned.
--

[%hardbreaks]
{blank}
| String

a| 
*resultCount* +
_required_
a| 

[markdown]
--
The total number of objects in the results.
--

[%hardbreaks]
{blank}
| Integer (unsigned)

a| 
*resultSize* +
_required_
a| 

[markdown]
--
The total number of bytes in the results.
--

[%hardbreaks]
{blank}
| Integer (unsigned)

a| 
*mutationCount* +
_optional_
a| 

[markdown]
--
The number of mutations that were made during the request.
--

[%hardbreaks]
{blank}
| Integer (unsigned)

a| 
*sortCount* +
_optional_
a| 

[markdown]
--
The number of objects that were sorted. Present only if the request includes `ORDER BY`.

If a query includes ORDER BY, LIMIT, or OFFSET clauses, an application can use the `sortCount` value to give the overall number of results in a message such as `"page 1 of N"`.

--

[%hardbreaks]
{blank}
| Integer (unsigned)

a| 
*usedMemory* +
_optional_
a| 

[markdown]
--
The amount of document memory used to execute the request. This property is only returned if a memory quota was set for the query.

--

[%hardbreaks]
{blank}
| Integer (unsigned)

a| 
*errorCount* +
_optional_
a| 

[markdown]
--
The number of errors that occurred during the request.
--

[%hardbreaks]
{blank}
| Integer (unsigned)

a| 
*warningCount* +
_optional_
a| 

[markdown]
--
The number of warnings that occurred during the request.
--

[%hardbreaks]
{blank}
| Integer (unsigned)

|===

//end::Metrics[]




include::{specDir}definitions/Metrics/definition-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/Metrics/definition-after.adoc[opts=optional]




// markup not found, no include::{specDir}definitions/Profile/definition-before.adoc[opts=optional]


ifdef::collapse-models[]
[discrete]
endif::collapse-models[]
[#Profile]
= Profile

:leveloffset: +1

// markup not found, no include::{specDir}definitions/Profile/definition-begin.adoc[opts=optional]


.icon:brackets-curly[fw] Object
{blank}

//tag::Profile[]

ifdef::model-descriptions[]
//tag::desc-Profile[]
An object containing monitoring and profiling information about the request. Present only if `profile` was set to `"phases"` or `"timings"` in the [Request Parameters](#Request).

//end::desc-Profile[]
endif::model-descriptions[]

[cols="25,55,20"]
|===
| Property | | Schema

a| 
*requestTime* +
_required_
a| 

[markdown]
--
Timestamp when the query was received.
--

[%hardbreaks]
{blank}
| Date (date-time)

a| 
*servicingHost* +
_required_
a| 

[markdown]
--
IP address and port number of the node where the query was executed.
--

[%hardbreaks]
{blank}
| String

a| 
*phaseCounts* +
_required_
a| 

[markdown]
--
Count of documents processed at selective phases involved in the query execution, such as authorize, index scan, fetch, parse, plan, run, etc.

--

[%hardbreaks]
*Example:* `{"fetch":16,"indexScan":187}`
{blank}
| Object

a| 
*phaseOperators* +
_required_
a| 

[markdown]
--
Indicates the numbers of each kind of query operator involved in different phases of the query processing.

For instance, a non-covering index path might involve one index scan and one fetch operator.
A join would probably involve two or more fetches, one per keyspace.
A union select would have twice as many operator counts, one per each branch of the union.

This is in essence the count of all the operators in the `executionTimings` object.

--

[%hardbreaks]
*Example:* `{"authorize":1,"fetch":1,"indexScan":2}`
{blank}
| Object

a| 
*phaseTimes* +
_required_
a| 

[markdown]
--
Cumulative execution times for various phases involved in the query execution, such as authorize, index scan, fetch, parse, plan, run, etc.

--

[%hardbreaks]
*Example:* `{"authorize":"823.631µs","fetch":"656.873µs","indexScan":"29.146543ms","instantiate":"236.221µs","parse":"826.382µs","plan":"11.831101ms","run":"16.892181ms"}`
{blank}
| Object

a| 
*executionTimings* +
_optional_
a| 

[markdown]
--
include::index.adoc[tag=desc-Execution_Timings, opts=optional]
--

[%hardbreaks]
{blank}
| <<Execution_Timings>>

|===

//end::Profile[]




// markup not found, no include::{specDir}definitions/Profile/definition-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/Profile/definition-after.adoc[opts=optional]




// markup not found, no include::{specDir}definitions/Request/definition-before.adoc[opts=optional]


ifdef::collapse-models[]
[discrete]
endif::collapse-models[]
[#Request]
= Request Parameters

:leveloffset: +1

// markup not found, no include::{specDir}definitions/Request/definition-begin.adoc[opts=optional]


.icon:brackets-curly[fw] Object
{blank}

//tag::Request[]


[cols="25,55,20"]
|===
| Property | | Schema

a| [#args]
*args* +
_optional_
a| 

[markdown]
--
Supplies the values for positional parameters in the statement.
Applicable if the statement or prepared statement contains 1 or more positional parameters.

The value is an array of JSON values, one for each positional parameter in the statement.

Refer to [Named Parameters and Positional Parameters][section_srh_tlm_n1b] for details.

[section_srh_tlm_n1b]: /server/7.6/n1ql/n1ql-manage/query-settings.html#section_srh_tlm_n1b

--

[%hardbreaks]
{blank}
| Object
list

a| [#atrcollection_req]
*atrcollection* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[atrcollection-srv]: #atrcollection-srv


endif::alt-markdown-links[]
Specifies the collection where the [active transaction record][additional-storage-use] (ATR) is stored.
The collection must be present.
If not specified, the ATR is stored in the default collection in the default scope in the bucket containing the first mutated document within the transaction.

The value must be a string in the form `"bucket.scope.collection"` or `"namespace:bucket.scope.collection"`.
If any part of the path contains a special character, that part of the path must be delimited in backticks &grave;&grave;.

The [node-level][atrcollection-srv] `atrcollection` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting.

[additional-storage-use]: /server/7.6/learn/data/transactions.html#active-transaction-record-entries
[atrcollection-srv]: ../n1ql-rest-admin/index.html#atrcollection-srv

--

[%hardbreaks]
*Example:* `pass:c["default:`travel-sample`.transaction.test"]`
{blank}
| String

a| [#auto_execute]
*auto_execute* +
_optional_
a| 

[markdown]
--
Specifies that prepared statements should be executed automatically as soon as they are created.
This saves you from having to make two separate requests in cases where you want to prepare a statement and execute it immediately.

Refer to [Auto-Execute][auto-execute] for more information.

[auto-execute]: /server/7.6/n1ql/n1ql-language-reference/prepare.html#auto-execute

--

[%hardbreaks]
*Default:* `false`
*Example:* `true`
{blank}
| Boolean

a| [#client_context_id]
*client_context_id* +
_optional_
a| 

[markdown]
--
A piece of data supplied by the client that is echoed in the response, if present.
SQL++ is agnostic about the content of this parameter; it is just echoed in the response.

* Maximum allowed size is 64 characters; all others will be cut.
* If it contains an escape character `/` or quote `"`, it will be rejected as error code 1110.

--

[%hardbreaks]
{blank}
| String

a| [#compression]
*compression* +
_optional_
a| 

[markdown]
--
Compression format to use for response data on the wire.

Values are case-insensitive.

--

[%hardbreaks]
*Values:* `"ZIP"`, `"RLE"`, `"LZMA"`, `"LZO"`, `"NONE"`
*Default:* `pass:c["NONE"]`
*Example:* `pass:c["zip"]`
{blank}
| String

a| [#controls_req]
*controls* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[controls-srv]: #controls-srv


endif::alt-markdown-links[]
Specifies if there should be a controls section returned with the request results.

When set to `true`, the query response document includes a controls section with runtime information provided along with the request, such as positional and named parameters or settings.

If the request qualifies for caching, these values will also be cached in the `completed_requests` system keyspace.

The [node-level][controls-srv] `controls` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting.

[controls-srv]: ../n1ql-rest-admin/index.html#controls-srv

--

[%hardbreaks]
*Example:* `true`
{blank}
| Boolean

a| [#creds]
*creds* +
_optional_
a| 

[markdown]
--
Specifies the login credentials.
The Query API supports two types of identity: local (or bucket) and admin.

The format is an identity and password.
You can specify credentials for multiple identities.

If credentials are supplied in the request header, then HTTP Basic Authentication takes precedence and `creds` is ignored.

--

[%hardbreaks]
{blank}
| <<Credentials>>
list

a| [#durability_level]
*durability_level* +
_optional_
a| 

[markdown]
--
The level of [durability][durability] for mutations produced by the request.

If the request contains a `BEGIN TRANSACTION` statement, or a DML statement with the [tximplicit](#tximplicit) parameter set to `true`, the durability level is specified for all mutations within that transaction.

Durability is also supported for non-transactional DML statements.
In this case, the `kvtimeout` parameter is used as the durability timeout.

If not specified, the default durability level is `"majority"`.
Set the durability level to `"none"` or `""` to specify no durability.

[durability]: /server/7.6/learn/data/durability.html

--

[%hardbreaks]
*Values:* `""`, `"none"`, `"majority"`, `"majorityAndPersistActive"`, `"persistToMajority"`
*Default:* `pass:c["majority"]`
*Example:* `pass:c["none"]`
{blank}
| String

a| [#encoded_plan]
*encoded_plan* +
_optional_
a| 

[markdown]
--
In Couchbase Server 6.5 and later, this parameter is ignored and has no effect.
It is included for compatibility with previous versions of Couchbase Server.

--

[%hardbreaks]
{blank}
| String

a| [#encoding]
*encoding* +
_optional_
a| 

[markdown]
--
Desired character encoding for the query results.

Only possible value is `UTF-8` and is case-insensitive.

--

[%hardbreaks]
*Default:* `pass:c["UTF-8"]`
{blank}
| String

a| [#format]
*format* +
_optional_
a| 

[markdown]
--
Desired format for the query results.

Values are case-insensitive.

--

[%hardbreaks]
*Values:* `"JSON"`, `"XML"`, `"CSV"`, `"TSV"`
*Default:* `pass:c["JSON"]`
*Example:* `pass:c["XML"]`
{blank}
| String

a| [#kvtimeout]
*kvtimeout* +
_optional_
a| 

[markdown]
--
The approximate time to wait for a KV get operation before timing out.
This applies to statements within a transaction, and to non-transactional statements, whether `durability_level` is set or not.

If `use_replica` is enabled for a query, then this parameter also specifies the approximate time to wait before fetching data from a replica vBucket when the active vBucket is inaccessible.

The value for this parameter is a string.
Its format includes an amount and a mandatory unit, e.g. `10ms` (10 milliseconds) or `0.5s` (half a second).
Valid units are:

* `ns` (nanoseconds)
* `us` (microseconds)
* `ms` (milliseconds)
* `s` (seconds)
* `m` (minutes)
* `h` (hours)

Specify a duration of `0` or a negative duration to disable.
When disabled, no timeout is applied and the KV operation runs for however long it takes.

--

[%hardbreaks]
*Default:* `pass:c["2.5s"]`
*Example:* `pass:c["10ms"]`
{blank}
| String

a| [#max_parallelism_req]
*max_parallelism* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[max-parallelism-srv]: #max-parallelism-srv
[queryMaxParallelism]: #queryMaxParallelism


endif::alt-markdown-links[]
Specifies the maximum parallelism for the query.

The [node-level][max-parallelism-srv] `max-parallelism` setting specifies the ceiling for this parameter for a single node.
If the request-level parameter is zero or negative, the parallelism for the query is set to the node-level setting.
If the request-level parameter is greater than zero and less than the node-level setting, the request-level parameter overrides the node-level setting.
If the request-level parameter is greater than the node-level setting, the parallelism for the query is set to the node-level setting.

In addition, the [cluster-level][queryMaxParallelism] `queryMaxParallelism` setting specifies the ceiling for this parameter for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

To enable queries to run in parallel, you must specify the cluster-level `queryMaxParallelism` parameter, or specify the node-level `max-parallelism` parameter on all Query nodes.

The default value is the same as the number of partitions of the index selected for the query.

[max-parallelism-srv]: ../n1ql-rest-admin/index.html#max-parallelism-srv
[queryMaxParallelism]: ../n1ql-rest-settings/index.html#queryMaxParallelism

--

[%hardbreaks]
*Example:* `3`
{blank}
| Integer (int32)

a| [#memory_quota_req]
*memory_quota* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[memory-quota-srv]: #memory-quota-srv
[queryMemoryQuota]: #queryMemoryQuota


endif::alt-markdown-links[]
Specifies the maximum amount of memory the request may use, in MB.

Specify `0` (the default value) to disable.
When disabled, there is no quota.

This parameter enforces a ceiling on the memory used for the tracked documents required for processing a request.
It does not take into account any other memory that might be used to process a request, such as the stack, the operators, or some intermediate values.

Within a transaction, this setting enforces the memory quota for the transaction by tracking the
delta table and the transaction log (approximately).

The [node-level][memory-quota-srv] `memory-quota` setting specifies the ceiling for this parameter for a single node.
If the node-level setting is zero (the default), the request-level parameter overrides the node-level setting.
If the node-level setting is greater than zero, the request-level parameter is capped by the node-level setting.

In addition, the [cluster-level][queryMemoryQuota] `queryMemoryQuota` setting specifies the ceiling for this parameter for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

[memory-quota-srv]: ../n1ql-rest-admin/index.html#memory-quota-srv
[queryMemoryQuota]: ../n1ql-rest-settings/index.html#queryMemoryQuota

--

[%hardbreaks]
*Default:* `0`
*Example:* `4`
{blank}
| Integer (int32)

a| [#metrics]
*metrics* +
_optional_
a| 

[markdown]
--
Specifies that metrics should be returned with query results.
--

[%hardbreaks]
*Default:* `true`
*Example:* `false`
{blank}
| Boolean

a| [#namespace]
*namespace* +
_optional_
a| 

[markdown]
--
Specifies the namespace to use. Currently, only the `default` namespace is available.

--

[%hardbreaks]
*Example:* `pass:c["default"]`
{blank}
| String

a| [#numatrs_req]
*numatrs* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[numatrs-srv]: #numatrs-srv
[queryNumAtrs]: #queryNumAtrs


endif::alt-markdown-links[]
Specifies the total number of [active transaction records][additional-storage-use].
Must be a positive integer.

The [node-level][numatrs-srv] `numatrs` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting.

In addition, the [cluster-level][queryNumAtrs] `queryNumAtrs` setting specifies the default for this parameter for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

[additional-storage-use]: /server/7.6/learn/data/transactions.html#active-transaction-record-entries
[numatrs-srv]: ../n1ql-rest-admin/index.html#numatrs-srv
[queryNumAtrs]: ../n1ql-rest-settings/index.html#queryNumAtrs

--

[%hardbreaks]
*Default:* `1024`
*Example:* `512`
{blank}
| Integer (int32)

a| [#pipeline_batch_req]
*pipeline_batch* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[pipeline-batch-srv]: #pipeline-batch-srv
[queryPipelineBatch]: #queryPipelineBatch


endif::alt-markdown-links[]
Controls the number of items execution operators can batch for Fetch from the KV.

The [node-level][pipeline-batch-srv] `pipeline-batch` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting, but only if it is lower than the node-level setting.

In addition, the [cluster-level][queryPipelineBatch] `queryPipelineBatch` setting specifies the default for this parameter for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

[pipeline-batch-srv]: ../n1ql-rest-admin/index.html#pipeline-batch-srv
[queryPipelineBatch]: ../n1ql-rest-settings/index.html#queryPipelineBatch

--

[%hardbreaks]
*Example:* `64`
{blank}
| Integer (int32)

a| [#pipeline_cap_req]
*pipeline_cap* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[pipeline-cap-srv]: #pipeline-cap-srv
[queryPipelineCap]: #queryPipelineCap


endif::alt-markdown-links[]
Maximum number of items each execution operator can buffer between various operators.

The [node-level][pipeline-cap-srv] `pipeline-cap` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting, but only if it is lower than the node-level setting.

In addition, the [cluster-level][queryPipelineCap] `queryPipelineCap` setting specifies the default for this parameter for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

[pipeline-cap-srv]: ../n1ql-rest-admin/index.html#pipeline-cap-srv
[queryPipelineCap]: ../n1ql-rest-settings/index.html#queryPipelineCap

--

[%hardbreaks]
*Example:* `1024`
{blank}
| Integer (int32)

a| [#prepared]
*prepared* +
_optional_
a| 

[markdown]
--
_Required_ if `statement` not provided.

The name of the prepared SQL++ statement to be executed.
Refer to [EXECUTE][execute] for examples.

If both `prepared` and `statement` are present and non-empty, an error is returned.

[execute]: /server/7.6/n1ql/n1ql-language-reference/execute.html

--

[%hardbreaks]
*Example:* `pass:c["[127.0.0.1:8091]pricy_hotel"]`
{blank}
| String

a| [#preserve_expiry]
*preserve_expiry* +
_optional_
a| 

[markdown]
--
Specifies whether documents should keep their current expiration setting when modified by a DML statement.

If `true`, documents will keep any existing expiration setting when modified by a DML statement.
If the DML statement explicitly specifies the document expiration, the statement overrides this parameter, and the expiration is changed.

If `false`, document expiration is set to 0 when modified by a DML statement, unless the DML statement explicitly specifies the document expiration.

Not supported for statements in a transaction.

--

[%hardbreaks]
*Default:* `false`
*Example:* `true`
{blank}
| Boolean

a| [#pretty_req]
*pretty* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[pretty-srv]: #pretty-srv


endif::alt-markdown-links[]
Specifies the query results returned in pretty format.

The [node-level][pretty-srv] `pretty` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting.

[pretty-srv]: ../n1ql-rest-admin/index.html#pretty-srv

--

[%hardbreaks]
*Example:* `false`
{blank}
| Boolean

a| [#profile_req]
*profile* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[profile-srv]: #profile-srv


endif::alt-markdown-links[]
Specifies if there should be a profile section returned with the request results.
The valid values are:

* `off` &mdash; No profiling information is added to the query response.

* `phases` &mdash;
The query response includes a profile section with stats and details about various phases of the query plan and execution.
Three phase times will be included in the `system:active_requests` and `system:completed_requests` monitoring keyspaces.

* `timings` &mdash;
Besides the phase times, the profile section of the query response document will include a full query plan with timing and information about the number of processed documents at each phase.
This information will be included in the `system:active_requests` and `system:completed_requests` keyspaces.

If `profile` is not set as one of the above values, then the profile setting does not change.

The [node-level][profile-srv] `profile` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting.

[profile-srv]: ../n1ql-rest-admin/index.html#profile-srv

--

[%hardbreaks]
*Values:* `"off"`, `"phases"`, `"timings"`
*Example:* `pass:c["phases"]`
{blank}
| String

a| [#query_context]
*query_context* +
_optional_
a| 

[markdown]
--
Specifies the namespace, bucket, and scope used to resolve partial keyspace references within the request.

The query context may be a _full path_, containing namespace, bucket, and scope; or a _relative path_, containing just the bucket and scope.
Currently, only the `default` namespace is available.
If the namespace name is omitted, the default namespace in the current session is used.

--

[%hardbreaks]
*Default:* `pass:c["default:"]`
*Example:* `pass:c["default:travel-sample.inventory"]`
{blank}
| String

a| [#readonly]
*readonly* +
_optional_
a| 

[markdown]
--
Controls whether a query can change a resulting recordset.

If `readonly` is `true`, then the following statements are not allowed:

* CREATE INDEX
* DROP INDEX
* INSERT
* MERGE
* UPDATE
* UPSERT

When using GET requests, it's best to set `readonly` to `true`.

--

[%hardbreaks]
*Default:* `false`
*Example:* `true`
{blank}
| Boolean

a| [#scan_cap_req]
*scan_cap* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[scan-cap-srv]: #scan-cap-srv
[queryScanCap]: #queryScanCap


endif::alt-markdown-links[]
Maximum buffered channel size between the indexer client and the query service for index scans.
This parameter controls when to use scan backfill.

Use `0` or a negative number to disable.
Smaller values reduce GC, while larger values reduce indexer backfill.

The [node-level][scan-cap-srv] `scan-cap` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting, but only if it is lower than the node-level setting.

In addition, the [cluster-level][queryScanCap] `queryScanCap` setting specifies the default for this parameter for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

[scan-cap-srv]: ../n1ql-rest-admin/index.html#scan-cap-srv
[queryScanCap]: ../n1ql-rest-settings/index.html#queryScanCap

--

[%hardbreaks]
*Example:* `1024`
{blank}
| Integer (int32)

a| [#scan_consistency]
*scan_consistency* +
_optional_
a| 

[markdown]
--
Specifies the consistency guarantee or constraint for index scanning.
The valid values are:

* `not_bounded` &mdash;
No timestamp vector is used in the index scan.
This is the fastest mode, because it avoids the costs of obtaining the vector and waiting for the index to catch up to the vector.

* `at_plus` &mdash;
This implements bounded consistency.
The request includes a `scan_vector` parameter and value, which is used as a lower bound.
This can be used to implement read-your-own-writes (RYOW).

* `request_plus` &mdash;
This implements strong consistency per request.
Before processing the request, a current vector is obtained.
The vector is used as a lower bound for the statements in the request.
If there are DML statements in the request, RYOW is also applied within the request.
(If `request_plus` is specified in a query that runs during a failover of an index node, the query waits until the rebalance operation completes and the index data has rebalanced before returning a result.)

* `statement_plus` &mdash;
This implements strong consistency per statement.
Before processing each statement, a current vector is obtained and used as a lower bound for that statement.

Values are case-insensitive.

For multi-statement requests, the default behavior is RYOW within each request.
If you want to disable RYOW within a request, add a separate `request_consistency` parameter that can be set to `not_bounded`.

If the request contains a `BEGIN TRANSACTION` statement, or a DML statement with the [tximplicit](#tximplicit) parameter set to `true`, then this parameter sets the transactional scan consistency.
Refer to [Transactional Scan Consistency][transactional-scan-consistency] for details.

[transactional-scan-consistency]: /server/7.6/n1ql/n1ql-manage/query-settings.html#transactional-scan-consistency

--

[%hardbreaks]
*Values:* `"not_bounded"`, `"at_plus"`, `"request_plus"`, `"statement_plus"`
*Default:* `pass:c["not_bounded"]`
*Example:* `pass:c["at_plus"]`
{blank}
| String

a| [#scan_vector]
*scan_vector* +
_optional_
a| 

[markdown]
--
_Required_ if `scan_consistency` is `at_plus` and `scan_vectors` not provided.

Specify the lower bound vector timestamp for one keyspace when using `at_plus` scan consistency.

Scan vectors are built of two-element [`value`, `guard`] entries:

* `value`: a vBucket's sequence number (a JSON number)
* `guard`: a vBucket's UUID (a string)

Scan vectors have two forms:

1. Full: an array of [`value`, `guard`] entries, giving an entry for every vBucket in the system.
2. Sparse: an object providing entries for specific vBuckets, mapping a vBucket number (a string) to each [`value`, `guard`] entry.

Note that `scan_vector` can only be used if the query uses at most one keyspace; if it is used for a query referencing more than one keyspace, the query will fail with an error.

For queries referencing multiple keyspaces, use `scan_vectors`.

--

[%hardbreaks]
*Example:* `{"5":[5409393,"VB5ID"],"19":[47574574,"VB19ID"]}`
{blank}
| Object

a| [#scan_vectors]
*scan_vectors* +
_optional_
a| 

[markdown]
--
_Required_ if `scan_consistency` is `at_plus` and `scan_vector` not provided.

A map from keyspace names to scan vectors.
See `scan_vector`.

The scan vectors can be Full or Sparse.

--

[%hardbreaks]
{blank}
| Object

a| [#scan_wait]
*scan_wait* +
_optional_
a| 

[markdown]
--
Can be supplied with `scan_consistency` values of `request_plus`, `statement_plus` and `at_plus`.

Specifies the maximum time the client is willing to wait for an index to catch up to the vector timestamp in the request.

Specifies how much time the client is willing to wait for the indexer to satisfy the required `scan_consistency` and `scan_vector` criteria.
After receiving the scan request, if the indexer is unable to catch up within the `scan_wait` time and initiate the scan, the indexer aborts with an error and the scan fails.

Its format includes an amount and a mandatory unit, e.g. `10ms` (10 milliseconds) or `0.5s` (half a second).
Valid units are:

* `ns` (nanoseconds)
* `us` (microseconds)
* `ms` (milliseconds)
* `s` (seconds)
* `m` (minutes)
* `h` (hours)

Specify `0` or a negative integer to disable.

--

[%hardbreaks]
*Default:* `pass:c[""]`
*Example:* `pass:c["30m"]`
{blank}
| String (duration)

a| [#signature]
*signature* +
_optional_
a| 

[markdown]
--
Include a header for the results schema in the response.
--

[%hardbreaks]
*Default:* `true`
*Example:* `false`
{blank}
| Boolean

a| [#sort_projection]
*sort_projection* +
_optional_
a| 

[markdown]
--
If `true`, causes statement projection terms to be sorted alphabetically.

If `false` (the default), statement projection terms are returned in the order specified by the query.

--

[%hardbreaks]
*Default:* `false`
*Example:* `true`
{blank}
| Boolean

a| [#statement]
*statement* +
_optional_
a| 

[markdown]
--
_Required_ if `prepared` not provided.

Any valid SQL++ statement for a POST request, or a read-only SQL++ statement (SELECT, EXPLAIN) for a GET request.

If both `prepared` and `statement` are present and non-empty, an error is returned.

---

When specifying the request parameters as form data, the statement may not contain an unescaped semicolon (`;`).
If it does, the Query Service responds with error 1040.
To avoid this, either URL-encode the semicolon as `%3B`, or just omit the semicolon if possible.

This restriction does not apply when specifying the request parameters in JSON format.

--

[%hardbreaks]
*Example:* `pass:c["SELECT * FROM `travel-sample`.inventory.hotel LIMIT 1"]`
{blank}
| String

a| [#timeout_req]
*timeout* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[timeout-srv]: #timeout-srv
[queryTimeout]: #queryTimeout


endif::alt-markdown-links[]
Maximum time to spend on the request before timing out.

The value for this parameter is a string.
Its format includes an amount and a mandatory unit, e.g. `10ms` (10 milliseconds) or `0.5s` (half a second).
Valid units are:

* `ns` (nanoseconds)
* `us` (microseconds)
* `ms` (milliseconds)
* `s` (seconds)
* `m` (minutes)
* `h` (hours)

Specify a duration of `0` or a negative duration to disable.
When disabled, no timeout is applied and the request runs for however long it takes.

If [tximplicit](#tximplicit) or [txid](#txid) is set, this parameter is ignored.
The request inherits the remaining time of the transaction as timeout.

The [node-level][timeout-srv] `timeout` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting.
However, if the node-level setting is greater than 0, the timeout for the query is limited to the node-level setting.

In addition, the [cluster-level][queryTimeout] `queryTimeout` setting specifies the default for this parameter for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

[timeout-srv]: ../n1ql-rest-admin/index.html#timeout-srv
[queryTimeout]: ../n1ql-rest-settings/index.html#queryTimeout

--

[%hardbreaks]
*Example:* `pass:c["30m"]`
{blank}
| String (duration)

a| [#txdata]
*txdata* +
_optional_
a| 

[markdown]
--
Transaction data.
For internal use only.

--

[%hardbreaks]
{blank}
| Object

a| [#txid]
*txid* +
_optional_
a| 

[markdown]
--
_Required_ for statements within a transaction.

Transaction ID.
Specifies the transaction to which a statement belongs.
For use with DML statements within a transaction, rollbacks, and commits.

The transaction ID should be the same as the transaction ID generated by the `BEGIN TRANSACTION` statement.
The transaction must be active and non-expired.

--

[%hardbreaks]
*Example:* `pass:c["d81d9b4a-b758-4f98-b007-87ba262d3a51"]`
{blank}
| UUID (UUID)

a| [#tximplicit]
*tximplicit* +
_optional_
a| 

[markdown]
--
Specifies that a DML statement is a singleton transaction.

When this parameter is true, the Query service starts a transaction and executes the statement.
If execution is successful, the Query service commits the transaction; otherwise the transaction is rolled back.

The statement may not be part of an ongoing transaction.
If the [txid](#txid) request-level parameter is set, the `tximplicit` parameter is ignored.

--

[%hardbreaks]
*Default:* `false`
*Example:* `true`
{blank}
| Boolean

a| [#txstmtnum]
*txstmtnum* +
_optional_
a| 

[markdown]
--
Transaction statement number.
The transaction statement number must be a positive integer, and must be higher than any previous transaction statement numbers in the transaction.
If the transaction statement number is lower than the transaction statement number for any previous statement, an error is generated.

--

[%hardbreaks]
*Example:* `10`
{blank}
| Integer (int32)

a| [#txtimeout_req]
*txtimeout* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[txtimeout-srv]: #txtimeout-srv
[queryTxTimeout]: #queryTxTimeout


endif::alt-markdown-links[]
Maximum time to spend on a transaction before timing out.
Only applies to `BEGIN TRANSACTION` statements, or DML statements for which [tximplicit](#tximplicit) is set.
For other statements, it is ignored.

Within a transaction, the request-level [timeout](#timeout_req) parameter is ignored.
The transaction timeout clock starts when the `BEGIN WORK` statement is successful.
Once the transaction timeout is reached, no statement is allowed to continue in the transaction.

The value for this parameter is a string.
Its format includes an amount and a mandatory unit, e.g. `10ms` (10 milliseconds) or `0.5s` (half a second).
Valid units are:

* `ns` (nanoseconds)
* `us` (microseconds)
* `ms` (milliseconds)
* `s` (seconds)
* `m` (minutes)
* `h` (hours)

Specify a duration of `0` to disable.
When disabled, the request-level timeout is set to the default.

The [node-level][txtimeout-srv] `txtimeout` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting.
However, if the node-level setting is greater than 0, the transaction timeout for the query is limited to the node-level setting.

In addition, the [cluster-level][queryTxTimeout] `queryTxTimeout` setting specifies the default for this parameter for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

The default is `"15s"` for cbq files or scripts, `"2m"` for interactive cbq sessions or redirected input.

[txtimeout-srv]: ../n1ql-rest-admin/index.html#txtimeout-srv
[queryTxTimeout]: ../n1ql-rest-settings/index.html#queryTxTimeout

--

[%hardbreaks]
*Example:* `pass:c["30m"]`
{blank}
| String (duration)

a| [#use_cbo_req]
*use_cbo* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[use-cbo-srv]: #use-cbo-srv
[queryUseCBO]: #queryUseCBO


endif::alt-markdown-links[]
Specifies whether the cost-based optimizer is enabled.

The [node-level][use-cbo-srv] `use-cbo` setting specifies the default for this parameter for a single node.
The request-level parameter overrides the node-level setting.

In addition, the [cluster-level][queryUseCBO] `queryUseCBO` setting specifies the default for this parameter for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

[use-cbo-srv]: ../n1ql-rest-admin/index.html#use-cbo-srv
[queryUseCBO]: ../n1ql-rest-settings/index.html#queryUseCBO

--

[%hardbreaks]
*Example:* `true`
{blank}
| Boolean

a| [#use_fts]
*use_fts* +
_optional_
a| [.edition]##{enterprise}##

[markdown]
--
Specifies that the query should use a full-text index.

If the query contains a `USING FTS` hint, that takes priority over this parameter.

If the query does not contain a `USING FTS` hint, and this parameter is set to true, all full-text indexes are considered for the query.
If a qualified full-text index is available, it is selected for the query.
If none of the available full-text indexes are qualified, the available GSI indexes are considered instead.

Refer to [Flex Indexes][flex-indexes] for more information.

[flex-indexes]: /server/7.6/n1ql/n1ql-language-reference/flex-indexes.html

--

[%hardbreaks]
*Default:* `false`
*Example:* `true`
{blank}
| Boolean

a| [#use_replica_req]
*use_replica* +
_optional_
a| 

[markdown]
--
ifdef::alt-markdown-links[]
[use-replica-srv]: #use-replica-srv
[queryUseReplica]: #queryUseReplica


endif::alt-markdown-links[]
Specifies whether a query can fetch data from a replica vBucket if active vBuckets are inaccessible.
The possible values are:

* `off` &mdash; read from replica is disabled for this request.

* `on` &mdash; read from replica is enabled for this request, unless it has been disabled for all requests at node level.

* `unset` &mdash; read from replica is specified by the node-level setting.
If the node-level setting is also `unset`, read from replica is disabled for this request.

The [node-level][use-replica-srv] `use-replica` setting specifies the default for this property for a single node.
The request-level parameter usually overrides the node-level setting.
However, when the node-level setting is `off`, the request-level parameter cannot enable the property.

In addition, the [cluster-level][queryUseReplica] `queryUseReplica` setting specifies the default for this property for the whole cluster.
When you change the cluster-level setting, the node-level setting is overwritten for all nodes in the cluster.

Do not enable read from replica when you require consistent results.
Only SELECT queries that are not within a transaction can read from replica.

Reading from replica is only possible if the cluster uses Couchbase Server 7.6.0 or later.

Note that KV range scans cannot currently be started on a replica vBucket.
If a query uses sequential scan and a data node becomes unavailable, the query might return an error, even if read from replica is enabled for the request.

[use-replica-srv]: ../n1ql-rest-admin/index.html#use-replica-srv
[queryUseReplica]: ../n1ql-rest-settings/index.html#queryUseReplica

--

[%hardbreaks]
*Values:* `"off"`, `"on"`, `"unset"`
*Default:* `pass:c["unset"]`
*Example:* `pass:c["true"]`
{blank}
| String

a| [#identifier]
_additional +
property_
a| 

[markdown]
--
Supplies the value for a named parameter in the statement.
Applicable if the statement or prepared statement contains 1 or more named parameters.

The name of this property consists of two parts:

1. The `$` character or the `@` character.
2. An identifier that specifies the name of the parameter.
    This must start with an alpha character, followed by one or more alphanumeric characters.

The value of the named parameter can be any JSON value.

Refer to [Named Parameters and Positional Parameters][section_srh_tlm_n1b] for details.

[section_srh_tlm_n1b]: /server/7.6/n1ql/n1ql-manage/query-settings.html#section_srh_tlm_n1b

--

[%hardbreaks]
{blank}
| String (any JSON value)

|===

//end::Request[]




// markup not found, no include::{specDir}definitions/Request/definition-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/Request/definition-after.adoc[opts=optional]




// markup not found, no include::{specDir}definitions/Response/definition-before.adoc[opts=optional]


ifdef::collapse-models[]
[discrete]
endif::collapse-models[]
[#Response]
= Response Body

:leveloffset: +1

// markup not found, no include::{specDir}definitions/Response/definition-begin.adoc[opts=optional]


.icon:brackets-curly[fw] Object
{blank}

//tag::Response[]

ifdef::model-descriptions[]
//tag::desc-Response[]
The response body has the following structure.
//end::desc-Response[]
endif::model-descriptions[]

[cols="25,55,20"]
|===
| Property | | Schema

a| 
*requestID* +
_optional_
a| 

[markdown]
--
A unique identifier for the response.
--

[%hardbreaks]
{blank}
| UUID (UUID)

a| 
*clientContextID* +
_optional_
a| 

[markdown]
--
The client context ID of the request, if one was supplied &mdash; see `client_context_id` in [Request Parameters](#Request).
--

[%hardbreaks]
{blank}
| String

a| 
*signature* +
_optional_
a| 

[markdown]
--
The schema of the results. Present only when the query completes successfully.

--

[%hardbreaks]
*Example:* `{"id":"json"}`
{blank}
| Object

a| 
*results* +
_optional_
a| 

[markdown]
--
An array of all the objects returned by the query. An object can be any JSON value.

--

[%hardbreaks]
{blank}
| Object
list

a| 
*status* +
_optional_
a| 

[markdown]
--
The status of the request.
--

[%hardbreaks]
*Values:* `"success"`, `"running"`, `"errors"`, `"completed"`, `"stopped"`, `"timeout"`, `"fatal"`
{blank}
| String

a| 
*errors* +
_optional_
a| 

[markdown]
--
An array of 0 or more error objects. If an error occurred during processing of the request, it will be represented by an error object in this list.

--

[%hardbreaks]
{blank}
| <<Conditions>>
list

a| 
*warnings* +
_optional_
a| 

[markdown]
--
An array of 0 or more warning objects. If a warning occurred during processing of the request, it is represented by a warning object in this list.

--

[%hardbreaks]
{blank}
| <<Conditions>>
list

a| 
*metrics* +
_optional_
a| 

[markdown]
--
include::index.adoc[tag=desc-Metrics, opts=optional]
--

[%hardbreaks]
{blank}
| <<Metrics>>

a| 
*controls* +
_optional_
a| 

[markdown]
--
include::index.adoc[tag=desc-Controls, opts=optional]
--

[%hardbreaks]
{blank}
| <<Controls>>

a| 
*profile* +
_optional_
a| 

[markdown]
--
include::index.adoc[tag=desc-Profile, opts=optional]
--

[%hardbreaks]
{blank}
| <<Profile>>

|===

//end::Response[]




// markup not found, no include::{specDir}definitions/Response/definition-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/Response/definition-after.adoc[opts=optional]




// markup not found, no include::{specDir}definitions/Statistics/definition-before.adoc[opts=optional]


ifdef::collapse-models[]
[discrete]
endif::collapse-models[]
[#Statistics]
= Statistics

:leveloffset: +1

// markup not found, no include::{specDir}definitions/Statistics/definition-begin.adoc[opts=optional]


.icon:brackets-curly[fw] Object
{blank}

//tag::Statistics[]

ifdef::model-descriptions[]
//tag::desc-Statistics[]
Statistics collected for the operator.
//end::desc-Statistics[]
endif::model-descriptions[]

[cols="25,55,20"]
|===
| Property | | Schema

a| 
*#itemsIn* +
_optional_
a| 

[markdown]
--
Number of input documents to the operator.
--

[%hardbreaks]
*Example:* `187`
{blank}
| Integer (int32)

a| 
*#itemsOut* +
_optional_
a| 

[markdown]
--
Number of output documents after the operator processing.
--

[%hardbreaks]
*Example:* `16`
{blank}
| Integer (int32)

a| 
*#phaseSwitches* +
_optional_
a| 

[markdown]
--
Number of switches between executing, waiting for services, or waiting for the goroutine scheduler.
--

[%hardbreaks]
*Example:* `413`
{blank}
| Integer (int32)

a| 
*execTime* +
_optional_
a| 

[markdown]
--
Time spent executing the operator code inside SQL++ query engine.
--

[%hardbreaks]
*Example:* `pass:c["128.434µs"]`
{blank}
| String (duration)

a| 
*kernTime* +
_optional_
a| 

[markdown]
--
Time spent waiting to be scheduled for CPU time.
--

[%hardbreaks]
*Example:* `pass:c["15.027879ms"]`
{blank}
| String (duration)

a| 
*servTime* +
_optional_
a| 

[markdown]
--
Time spent waiting for another service, such as index or data.

For index scan, it is time spent waiting for GSI/indexer.

For fetch, it is time spent waiting on the KV store.

--

[%hardbreaks]
*Example:* `pass:c["1.590934ms"]`
{blank}
| String (duration)

|===

//end::Statistics[]




include::{specDir}definitions/Statistics/definition-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/Statistics/definition-after.adoc[opts=optional]




// markup not found, no include::{specDir}definitions/document-end.adoc[opts=optional]


:leveloffset: -1

// markup not found, no include::{specDir}definitions/document-after.adoc[opts=optional]



// markup not found, no include::{specDir}security/document-before.adoc[opts=optional]


[[security]]
= Security

:leveloffset: +1

include::{specDir}security/document-begin.adoc[opts=optional]




// markup not found, no include::{specDir}security/Header/security-scheme-before.adoc[opts=optional]


[[security-header]]
= Header

:leveloffset: +1

// markup not found, no include::{specDir}security/Header/security-scheme-begin.adoc[opts=optional]


[markdown]
--
Specify a user name and password via HTTP headers.
This method can only be used to provide a single credential.

--

[%hardbreaks]
__Type__ : http


// markup not found, no include::{specDir}security/Header/security-scheme-end.adoc[opts=optional]

:leveloffset: -1


// markup not found, no include::{specDir}security/Header/security-scheme-after.adoc[opts=optional]




// markup not found, no include::{specDir}security/Parameter/security-scheme-before.adoc[opts=optional]


[[security-parameter]]
= Parameter

:leveloffset: +1

// markup not found, no include::{specDir}security/Parameter/security-scheme-begin.adoc[opts=optional]


[markdown]
--
Specify user names and passwords via the `creds` request parameter. This is the only method that can provide multiple credentials for a request.

--

.API Key
[%hardbreaks]
__Key parameter__ : creds
__Key in__ : query 


// markup not found, no include::{specDir}security/Parameter/security-scheme-end.adoc[opts=optional]

:leveloffset: -1


// markup not found, no include::{specDir}security/Parameter/security-scheme-after.adoc[opts=optional]




include::{specDir}security/document-end.adoc[opts=optional]

:leveloffset: -1



include::{specDir}security/document-after.adoc[opts=optional]

